#+TITLE: My Copy of Bugbench

Bugbench is a benchmark suite created by Shan Lu.

* Why creating this repo?
- I need to access bugbench many times
- The copy I got needs some modification (compiler flags) to run on Linux
- I need take some notes
- I want to create bug signature along with it


* Statistics

| benchmark               | deterministic | original benchmark | patched version    | manual bug signature | patched version | Comment                                              |
|-------------------------+---------------+--------------------+--------------------+----------------------+-----------------+------------------------------------------------------|
| gzip-1.2.4              | Y             | Y                  | N (official patch) | Y                    | N               |                                                      |
| ncompress-4.2.4         | Y             | Y                  | N (manual patch)   | Y                    | N               |                                                      |
| polymorph-0.4.0 (bug 1) | Y             | Y                  | N (manual patch)   | Y                    | N               |                                                      |
| bc-1.06 (bug 3)         | Y             | Y                  | N (manual patch)   | N/A                  | N/A             | Too complicated. code is generated by flex and bison |
| man-1.5h1               | Y             | Y                  | N (manual patch)   | Y                    | N               |                                                      |


| benchmark               | deterministic | original benchmark | patched version | manual bug signature | patched version | Comment                                                             |
|-------------------------+---------------+--------------------+-----------------+----------------------+-----------------+---------------------------------------------------------------------|
| bc-1.06 (bug 1)         |               | N/A                |                 |                      |                 | No bug triggering input                                             |
| bc-1.06 (bug 2)         |               | N/A                |                 |                      |                 | No bug triggering input                                             |
| polymorph-0.4.0 (bug 2) |               | N/A                |                 |                      |                 | No bug triggering input                                             |
| squid-2.3               |               | N/A                |                 |                      |                 | Complicate to run, don't know how to start and connect squid server |
| cvs-1.11.4              |               | N/A                |                 |                      |                 | Require running cvs server, no exploit-cvs.c file found             |

* Directory layout
In each benchmark directory, the three folders are added by me:
- =./*slice.txt= slice performed on the property violation line (the criteria file is =./src/slicing-criteria.txt=)
- =./patch= the patch that can fix the bug
- =./helium= the folder containing bug signature.
- =./helium/addition= the bug signature created manually
- =./helium/slicing= the bug signature created based on slice

* Slicing experiment
** Overview
| benchmark |  LOC | full slice size | data slice | control slice | comment                                    |
|-----------+------+-----------------+------------+---------------+--------------------------------------------|
| gzip      | 5225 |            1982 |          1 |            55 | data slice is actually the criteria itself |
| ncompress | 1436 |             450 |          1 |            63 |                                            |
| polymorph |  404 |              20 |          1 |            19 |                                            |
| man       | 3036 |            1992 |       1206 |            90 |                                            |

** Conclusion from experiment
1. all statements in manual created bug signature are in the slice
2. full slice is much bigger than bug signature
3. understand the reasons that full slice can not simply built (see next sub-section)
4. It is possible to /carefully/ remove statements not in slice to make slice built,
   and can trigger the bug.
5. The reason for slice to be so big.
   The reasons can be 1) control slice 2) correct path 3) compute irrelevant results.
   The first and third reason seem to be primary reasons for these benchmarks.

** Reasons for slice not built
1. slice will not contain the syntax meaningless constructs, like
   - parenthesis,
   - else clause,
   - multi-line statements.
   - =do= while
   These hinder building.
   The use of AST can help this.
2. slicing may not include the declaration of a variable, results in compile error.
3. typedef is not included in slice
4. Some global variables are not in slice, but is used in many places, including some statements in slice.
5. if branches contains only one statement, which is also not in slice. Cannot simply delete it
6. ...


# ** Proposed how to use slice, and next step
# 1. automate manual removing statement process
# 2. automate slicing built process by using AST level statement removal.

* Bug Signature Ground Truth

** gzip
#+BEGIN_SRC C
local void treat_file(iname)
    char *iname;
{
    /* Check if the input file is present, set ifname and istat: */
    if (get_istat(iname, &istat) != OK) return;
}
local int get_istat(iname, sbuf)
    char *iname;
    struct stat *sbuf;
{
    strcpy(ifname, iname);
}
int main (argc, argv)
    int argc;
    char **argv;
{
    int file_count;     /* number of files to precess */
    strncpy(z_suffix, Z_SUFFIX, sizeof(z_suffix)-1);
    z_len = strlen(z_suffix);
    file_count = argc - optind;
    /* And get to work */
    if (file_count != 0) {
        while (optind < argc) {
	    treat_file(argv[optind++]);
	}
    }
    return exit_code; /* just to avoid lint warning */
}
#+END_SRC

** ncompress
#+BEGIN_SRC C
void
main(argc, argv)
	REG1	int 	 argc;
	REG2	char	*argv[];
	{
    	REG3	char		**filelist;
		REG4	char		**fileptr;
	filelist = fileptr = (char **)malloc(argc*sizeof(fileptr[0]));
    	for (argc--, argv++; argc > 0; argc--, argv++)
		{
			if (**argv == '-')
			{/* A flag argument */
		    	while (*++(*argv))
				{/* Process all flags in this arg */
		    	}
			}
			else
			{
		    	*fileptr++ = *argv;	/* Build input file list */
		    	*fileptr = NULL;
			}
    	}
    	if (*filelist != NULL)
	{
        	for (fileptr = filelist; *fileptr; fileptr++)
			comprexx(fileptr);
    	}
}
void
comprexx(fileptr)
	char	**fileptr;
	{
		char	tempname[MAXPATHLEN];
                printf("comprexx\n");
		strcpy(tempname,*fileptr);
	}
#+END_SRC
** polymorph
#+BEGIN_SRC C
void grok_commandLine(int argc, char *argv[]){
	int o;
	while( ( o = getopt( argc, argv, "achtvf:" ) ) != -1 ){
		switch( o ){
			case 'f':
				strcpy( target, optarg );
				break;
			default:
				exit( 0 );
		}
	}
}/* end of grok_commandLine */
int main(int argc, char *argv[]){
  grok_commandLine( argc, argv );
  return( 0 );
}/* end of main */
#+END_SRC
** man
=man.c=
#+BEGIN_SRC C
static int
man (char *name, char *section) {
     int found, type, flags;
     struct manpage *mp;
     found = 0;
     init_manpath();
     // ADDED BY HELIUM
     type = TYPE_MAN;
     flags = type;
     mp = manfile(name, section, flags, section_list, mandirlist,
		  convert_to_cat);
     found = 0;
     return found;
}

static char **
get_section_list (void) {
     int i;
     char *p;
     char *end;
     static char *tmp_section_list[100];
     i = 0;
     for (p = colon_sep_section_list; ; p = end+1) {
	  if ((end = strchr (p, ':')) != NULL)
	       *end = '\0';
	  tmp_section_list[i++] = my_strdup (p);

	  /* if (end == NULL || i+1 == sizeof(tmp_section_list)/sizeof(char*)) */
	  if (end == NULL || i+1 == sizeof(tmp_section_list))
	       break;
     }
     tmp_section_list [i] = NULL;
     return tmp_section_list;
}
int
main (int argc, char **argv) {
     int status = 0;
     char *nextarg;
     char *section = 0;
     man_getopt (argc, argv);
     section_list = get_section_list ();
     while (optind < argc) {
	  nextarg = argv[optind++];
	    //<------------segment fault within man~~~
	  status = man (nextarg, section);
     }
     return !status;
}
#+END_SRC
=manfile.c=
#+BEGIN_SRC C
static void
append(struct manpage **head, struct manpage *a) {
     struct manpage *p;

     if (a) {
	  if (*head) {
	       p = *head;
	       while(p->next)
		    p = p->next;
	       p->next = a;
	  } else
	       *head = a;
     }
}
static int
my_lth(char *s) {
     return s ? strlen(s) : 0;
}
static char **
glob_for_file_ext_glob (char *dir, char *sec, char *name, char *ext, char *hpx,
			int glob, int type) {
  printf("entering glob_for_file_ext_glob\n");
     char *pathname;
     char *p;
     char **names;
     int len;

     len = my_lth(dir) + my_lth(sec) + my_lth(hpx) + my_lth(name)
	  + my_lth(ext) + 8;
     pathname = (char *) malloc(len);
     if (!pathname)
	  return 0;
     if (type == TYPE_CAT) {
          p = to_cat_filename(pathname, 0, standards);
          if (p) {
          } else {
               sprintf (pathname, "%s/cat%s%s/%s.%s%s",
                        dir, sec, hpx, name, ext, glob ? "*" : "");
	  }
     }
     names = glob_filename (pathname);
     return names;
}

static char **
glob_for_file_ext (char *dir, char *sec, char *name, char *ext, int type) {
     char **names, **namesglob;
     char *hpx = ((standards & DO_HP) ? ".Z" : "");
     namesglob = glob_for_file_ext_glob(dir,sec,name,ext,hpx,1,type);
     return namesglob;
}

static char **
glob_for_file (char *dir, char *sec, char *name, int type) {
     char **names;
     names = glob_for_file_ext (dir, sec, name, sec, type);
     return names;
}
static struct manpage *
manfile_from_sec_and_dir(char *dir, char *sec, char *name, int flags) {
     struct manpage *res = 0;
     struct manpage *p;
     char **names, **np;
     int types[3] = { TYPE_MAN, TYPE_CAT, TYPE_SCAT };
     int i, type;
     for (i=0; i<3; i++) {
	  type = types[i];
	  if (flags & type) {
	       names = glob_for_file (dir, sec, name, type);
	  }
     }
     return res;
}
static struct manpage *
manfile_from_section(char *name, char *section, int flags, char **manpath) {
     char **mp;
     struct manpage *res = 0;
     for (mp = manpath; *mp; mp++) {
	  append(&res, manfile_from_sec_and_dir(*mp, section, name, flags));
     }
     return res;
}
struct manpage *
manfile(char *name, char *section, int flags,
        char **sectionlist, char **manpath,
	char *((*tocat)(char *man_filename, char *ext, int flags))) {
     char **sl;
     struct manpage *res;
	  for (sl = sectionlist; *sl; sl++) {
	       append(&res, manfile_from_section(name, *sl, flags, manpath));
	  }
     return res;
}
#+END_SRC
